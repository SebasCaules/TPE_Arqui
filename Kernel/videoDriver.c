#include <videoDriver.h>
#define WINDOW_WIDTH 1024
#define WINDOW_HEIGHT 768
#define BORDER_PADDING 50
#define VERTICAL_PADDING 4
#define CHAR_HEIGHT 16
#define CHAR_WIDTH 8

struct vbe_mode_info_structure {
	uint16_t attributes;		// deprecated, only bit 7 should be of interest to you, and it indicates the mode supports a linear frame buffer.
	uint8_t window_a;			// deprecated
	uint8_t window_b;			// deprecated
	uint16_t granularity;		// deprecated; used while calculating bank numbers
	uint16_t window_size;
	uint16_t segment_a;
	uint16_t segment_b;
	uint32_t win_func_ptr;		// deprecated; used to switch banks from protected mode without returning to real mode
	uint16_t pitch;			// number of bytes per horizontal line
	uint16_t width;			// width in pixels
	uint16_t height;			// height in pixels
	uint8_t w_char;			// unused...
	uint8_t y_char;			// ...
	uint8_t planes;
	uint8_t bpp;			// bits per pixel in this mode
	uint8_t banks;			// deprecated; total number of banks in this mode
	uint8_t memory_model;
	uint8_t bank_size;		// deprecated; size of a bank, almost always 64 KB but may be 16 KB...
	uint8_t image_pages;
	uint8_t reserved0;

	uint8_t red_mask;
	uint8_t red_position;
	uint8_t green_mask;
	uint8_t green_position;
	uint8_t blue_mask;
	uint8_t blue_position;
	uint8_t reserved_mask;
	uint8_t reserved_position;
	uint8_t direct_color_attributes;

	uint32_t framebuffer;		// physical address of the linear frame buffer; write here to draw to the screen
	uint32_t off_screen_mem_off;
	uint16_t off_screen_mem_size;	// size of memory in the framebuffer but not being displayed on the screen
	uint8_t reserved1[206];
} __attribute__ ((packed));

typedef struct vbe_mode_info_structure * VBEInfoPtr;

VBEInfoPtr VBE_mode_info = (VBEInfoPtr) 0x0000000000005C00;

void putPixel(uint32_t hexColor, uint64_t x, uint64_t y) {
    uint8_t * framebuffer = (uint8_t *) VBE_mode_info->framebuffer;
    uint64_t offset = (x * ((VBE_mode_info->bpp)/8)) + (y * VBE_mode_info->pitch);
    framebuffer[offset]     =  (hexColor) & 0xFF;
    framebuffer[offset+1]   =  (hexColor >> 8) & 0xFF; 
    framebuffer[offset+2]   =  (hexColor >> 16) & 0xFF;
}

uint16_t getWidth() {
	return VBE_mode_info->width;
}

uint16_t getHeight() {
	return VBE_mode_info->height;
}

uint8_t font_bitmap[94][16] = {
    // ASCII 32: ' ' (space)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    
    // ASCII 33: '!'
    {0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
    
    // ASCII 34: '"'
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 35: '#'
    {0x00, 0x36, 0x36, 0x7F, 0x7F, 0x36, 0x7F, 0x7F,
    0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    
    // ASCII 36: '$'
    {0x00, 0x18, 0x3E, 0x60, 0x3C, 0x06, 0x3E, 0x18,
    0x18, 0x18, 0x7E, 0x18, 0x00, 0x00, 0x00, 0x00},

    // ASCII 37: '%'
    {0x00, 0x63, 0x63, 0x06, 0x0C, 0x18, 0x30, 0x60,
    0x60, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 38: '&'
    {0x00, 0x3C, 0x66, 0x66, 0x3C, 0x78, 0x6C, 0x66,
    0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 39: '''
    {0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 40: '('
    {0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 41: ')'
    {0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00},

    // ASCII 42: '*'
    {0x00, 0x18, 0x7E, 0x3C, 0x66, 0x3C, 0x7E, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 43: '+'
    {0x00, 0x18, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 44: ','
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00},

    // ASCII 45: '-'
    {0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 46: '.'
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 47: '/'
    {0x00, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x60, 0x60,
    0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

	// ASCII 48: '0'
    {0x00, 0x3C, 0x66, 0x66, 0x6E, 0x76, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},
     
    // ASCII 49: '1'
    {0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00},
     
    // ASCII 50: '2'
    {0x00, 0x3C, 0x66, 0x66, 0x06, 0x0C, 0x18, 0x30,
     0x60, 0x60, 0x66, 0x7E, 0x00, 0x00, 0x00, 0x00},

    // ASCII 51: '3'
    {0x00, 0x7E, 0x66, 0x06, 0x06, 0x1C, 0x06, 0x06,
     0x06, 0x06, 0x66, 0x7E, 0x00, 0x00, 0x00, 0x00},

    // ASCII 52: '4'
    {0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0x6C, 0xCC, 0xFE,
     0x0C, 0x0C, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 53: '5'
    {0x00, 0x7E, 0x60, 0x60, 0x7C, 0x06, 0x06, 0x06,
     0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 54: '6'
    {0x00, 0x3C, 0x66, 0x66, 0x60, 0x7C, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 55: '7'
    {0x00, 0x7E, 0x66, 0x06, 0x0C, 0x18, 0x18, 0x30,
     0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00},

    // ASCII 56: '8'
    {0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 57: '9'
    {0x00, 0x3C, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06,
     0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 58: ':'
    {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
     0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 59: ';'
    {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
     0x00, 0x18, 0x18, 0x30, 0x30, 0x00, 0x00, 0x00},

    // ASCII 60: '<'
    {0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30,
     0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00},

    // ASCII 61: '='
    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
     0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 62: '>'
    {0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x0C, 0x0C,
     0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00},

    // ASCII 63: '?'
    {0x00, 0x3C, 0x66, 0x66, 0x06, 0x0C, 0x18, 0x18,
     0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
	 // ASCII 64: '@'
    {0x00, 0x3C, 0x42, 0x5A, 0x5A, 0x5A, 0x5A, 0x5C,
     0x40, 0x40, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00},
     
    // ASCII 65: 'A'
    {0x00, 0x18, 0x24, 0x42, 0x42, 0x42, 0x7E, 0x42,
     0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00},
     
    // ASCII 66: 'B'
    {0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 67: 'C'
    {0x00, 0x3C, 0x66, 0x66, 0x60, 0x60, 0x60, 0x60,
     0x60, 0x60, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00},

    // ASCII 68: 'D'
    {0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 69: 'E'
    {0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60,
     0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00},

    // ASCII 70: 'F'
    {0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60,
     0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00},

    // ASCII 71: 'G'
    {0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x6E, 0x66,
     0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 72: 'H'
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},

    // ASCII 73: 'I'
    {0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00},

    // ASCII 74: 'J'
    {0x00, 0x7E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
     0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 75: 'K'
    {0x00, 0x66, 0x66, 0x6C, 0x6C, 0x78, 0x78, 0x78,
     0x6C, 0x6C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},

    // ASCII 76: 'L'
    {0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
     0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00},

    // ASCII 77: 'M'
    {0x00, 0x66, 0x66, 0x7E, 0x7E, 0x7E, 0x7E, 0x66,
     0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},

    // ASCII 78: 'N'
    {0x00, 0x66, 0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x6E,
     0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},

    // ASCII 79: 'O'
    {0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},

	// ASCII 80: 'P'
    {0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60,
     0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00},
     
    // ASCII 81: 'Q'
    {0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x76, 0x3E, 0x00, 0x06, 0x06, 0x00},
     
    // ASCII 82: 'R'
    {0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x6C,
     0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},

    // ASCII 83: 'S'
    {0x00, 0x3E, 0x60, 0x60, 0x60, 0x3C, 0x06, 0x06,
     0x06, 0x06, 0x06, 0x7C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 84: 'T'
    {0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},

    // ASCII 85: 'U'
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 86: 'V'
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00},

    // ASCII 87: 'W'
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x7E,
     0x7E, 0x7E, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},

    // ASCII 88: 'X'
    {0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C,
     0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},

    // ASCII 89: 'Y'
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18,
     0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},

    // ASCII 90: 'Z'
    {0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x60,
     0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

	 // ASCII 91: '['
    {0x00, 0x3E, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30, 0x30, 0x3E, 0x00, 0x00, 0x00, 0x00},

    // ASCII 92: '\'
    {0x00, 0x60, 0x60, 0x30, 0x30, 0x30, 0x18, 0x18,
     0x18, 0x0C, 0x0C, 0x06, 0x06, 0x00, 0x00, 0x00},

    // ASCII 93: ']'
    {0x00, 0x3E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
     0x06, 0x06, 0x06, 0x3E, 0x00, 0x00, 0x00, 0x00},

    // ASCII 94: '^'
    {0x00, 0x18, 0x3C, 0x66, 0x66, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 95: '_'
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00},

	 // ASCII 96: '`'
    {0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
     
    // ASCII 97: 'a'
    {0x00, 0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66,
     0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00},
     
    // ASCII 98: 'b'
    {0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 99: 'c'
    {0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60,
     0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 100: 'd'
    {0x00, 0x06, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 101: 'e'
    {0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60,
     0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 102: 'f'
    {0x00, 0x0E, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 103: 'g'
    {0x00, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x3E, 0x06, 0x3C, 0x00, 0x00, 0x00},

    // ASCII 104: 'h'
    {0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 105: 'i'
    {0x00, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00},

    // ASCII 106: 'j'
    {0x00, 0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x06,
     0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00},

    // ASCII 107: 'k'
    {0x00, 0x60, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78,
     0x6C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 108: 'l'
    {0x00, 0x60, 0x70, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 109: 'm'
    {0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x7E,
     0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 110: 'n'
    {0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 111: 'o'
    {0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},

	 // ASCII 112: 'p'
    {0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00, 0x00},
     
    // ASCII 113: 'q'
    {0x00, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x3E, 0x06, 0x06, 0x06, 0x00, 0x00},
     
    // ASCII 114: 'r'
    {0x00, 0x00, 0x00, 0x00, 0x6E, 0x38, 0x30, 0x30,
     0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 115: 's'
    {0x00, 0x00, 0x00, 0x00, 0x3E, 0x60, 0x60, 0x3C,
     0x06, 0x06, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 116: 't'
    {0x00, 0x18, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 117: 'u'
    {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 118: 'v'
    {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00},

    // ASCII 119: 'w'
    {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x7E,
     0x7E, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 120: 'x'
    {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x18,
     0x3C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 121: 'y'
    {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
     0x66, 0x66, 0x3E, 0x06, 0x7C, 0x00, 0x00, 0x00},

    // ASCII 122: 'z'
    {0x00, 0x00, 0x00, 0x00, 0x7E, 0x06, 0x0C, 0x18,
     0x30, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00},

    // ASCII 123: '{'
    {0x00, 0x0C, 0x18, 0x18, 0x18, 0x30, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00},

    // ASCII 124: '|'
    {0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},

    // ASCII 125: '}'
    {0x00, 0x30, 0x18, 0x18, 0x18, 0x0C, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00},

    // ASCII 126: '~'
    {0x00, 0x00, 0x00, 0x32, 0x4C, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

};



void drawchar(unsigned char c, int x, int y, int fgcolor, int bgcolor) {
	int cx,cy;
	int mask[8]={128,64,32,16,8,4,2,1};
	unsigned char *glyph=font_bitmap[c - 32];

	for(cy=0;cy<16;cy++){
		
		for(cx=0;cx<8;cx++){
			putPixel(glyph[cy]&mask[cx]?fgcolor:bgcolor,x+cx,y+cy-12);
		}
	}
}

// Global variables to store the current position
int currentX = BORDER_PADDING;
int currentY = BORDER_PADDING;

void printStr(char* str, int fgcolor, int bgcolor) {
    while (*str) {
        // Handle newlines in the string
        if (*str == '\n') {
            currentX = BORDER_PADDING;  // Reset x to the left margin
            currentY += CHAR_HEIGHT + VERTICAL_PADDING;  // Move y to the next line with padding
            str++;  // Move to the next character
            continue;
        }

        // Find the length of the next word (sequence of non-space characters)
        int word_start = 0;
        while (str[word_start] && str[word_start] != ' ' && str[word_start] != '\n') {
            word_start++;
        }
        int word_length = word_start;

        // Check if the word fits in the remaining space on the current line
        if (currentX + word_length * CHAR_WIDTH > WINDOW_WIDTH - BORDER_PADDING) {
            // Move to the next line if the word doesn't fit
            currentX = BORDER_PADDING;  // Reset to the start of the new line
            currentY += CHAR_HEIGHT + VERTICAL_PADDING;  // Move to the next line with padding
        }

        // Check if we're hitting the bottom boundary
        if (currentY + CHAR_HEIGHT > WINDOW_HEIGHT - BORDER_PADDING) {
            // Stop printing if we're beyond the allowed window space
            return;
        }

        // Print the word character by character
        for (int i = 0; i < word_length; i++) {
            drawchar(str[i], currentX, currentY, fgcolor, bgcolor);
            currentX += CHAR_WIDTH;
        }

        // Skip consecutive spaces and handle them as a single space
        str += word_length;
        if (*str == ' ') {
            // Handle the first space after the word
            if (currentX + CHAR_WIDTH > WINDOW_WIDTH - BORDER_PADDING) {
                currentX = BORDER_PADDING;  // Reset x to the start of the next line
                currentY += CHAR_HEIGHT + VERTICAL_PADDING;  // Move to the next line with padding
            } else {
                currentX += CHAR_WIDTH;  // Move x for the space
            }

            // Skip any consecutive spaces after the first one
            while (*str == ' ') {
                str++;  // Skip multiple spaces
            }
        }
    }
}

void printCharBW(char c) {
    // Define character width, height, and space limits
    const int charWidth = 8;
    const int charHeight = 16;

    // Check if the character is a space or newline
    if (c == ' ') {
        // Handle space character by advancing the current position
        currentX += charWidth;
    } else if (c == '\n') {
        // Handle newline by resetting x position and moving to the next line
        currentX = BORDER_PADDING;
        currentY += charHeight + VERTICAL_PADDING;
    } else {
        // Check if the character will go out of bounds and wrap if needed
        if (currentX + charWidth > WINDOW_WIDTH - BORDER_PADDING) {
            // Move to the next line if no space for the character
            currentX = BORDER_PADDING;
            currentY += charHeight + VERTICAL_PADDING;
        }
        
        // Call drawchar() to print the character at the current position
        drawchar(c, currentX, currentY, 0x00FFFFFF, 0x00000000);
        
        // Update currentX for the next character
        currentX += charWidth;
    }
    
    // Check if we go beyond the window height
    if (currentY + charHeight > WINDOW_HEIGHT - BORDER_PADDING) {
        // Reset Y position or handle screen overflow as necessary
        currentY = BORDER_PADDING;  // Optionally reset or scroll
    }
}

void printStrBW(char* str){
	uint32_t foregroundColor = 0x00FFFFFF; // White color in RGB
    uint32_t backgroundColor = 0x00000000; // Black color in RGB
	printStr(str, foregroundColor, backgroundColor);
}

void printNewLine(){
	currentX = BORDER_PADDING;
	currentY += CHAR_HEIGHT + VERTICAL_PADDING;
}

void reverseStr(char *str, int length) {
    int start = 0;
    int end = length - 1;
    while (start < end) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        start++;
        end--;
    }
}

void intToStr(int num, char *str) {
    int i = 0;
    do {
        str[i++] = (num % 10) + '0';
        num /= 10;
    } while (num > 0);
    str[i] = '\0';
    reverseStr(str, i);
}
